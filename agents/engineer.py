import json
import os
import datetime

class EngineerAgent:
    def __init__(self, output_folder="data/output", query="Object"):
        self.output_folder = output_folder
        self.query = query
        
        # Handle comma-separated queries
        self.categories = [q.strip() for q in query.split(',')]
        self.cat_name_to_id = {name: i+1 for i, name in enumerate(self.categories)}
        
        self.coco_data = {
            "info": {
                "year": datetime.datetime.now().year,
                "version": "1.0",
                "description": f"Dataset for {query} generated by Foundry",
                "contributor": "Foundry Agent",
                "url": "",
                "date_created": datetime.datetime.now().isoformat()
            },
            "licenses": [],
            "images": [],
            "annotations": [],
            "categories": [
                {"id": i+1, "name": name, "supercategory": "object"} 
                for i, name in enumerate(self.categories)
            ]
        }
        self.annotation_id = 1
        self.image_id = 1

    def process_item(self, filename, data):
        """Adds a single image's annotations to the COCO dataset."""
        # Add Image
        self.coco_data["images"].append({
            "id": self.image_id,
            "width": data["width"],
            "height": data["height"],
            "file_name": filename,
            "license": 0,
            "flickr_url": "",
            "coco_url": "",
            "date_captured": ""
        })
        
        # Add Annotation
        # Expecting bboxes to be a list of dicts: {'label': 'cat', 'bbox': [ymin, xmin, ymax, xmax]}
        # OR legacy list of lists: [[ymin, xmin, ymax, xmax]] (default to first category)
        
        items = data["bboxes"]
        
        for item in items:
            if isinstance(item, list):
                # Legacy format
                bbox_norm = item
                category_id = 1
            else:
                # New format
                bbox_norm = item['bbox']
                label = item.get('label')
                # Try to match label to category, default to 1 if not found or fuzzy match?
                # For now, assume exact match or first category
                category_id = self.cat_name_to_id.get(label, 1)

            ymin, xmin, ymax, xmax = bbox_norm
            
            abs_x = (xmin / 1000) * data["width"]
            abs_y = (ymin / 1000) * data["height"]
            abs_w = ((xmax - xmin) / 1000) * data["width"]
            abs_h = ((ymax - ymin) / 1000) * data["height"]
            
            self.coco_data["annotations"].append({
                "id": self.annotation_id,
                "image_id": self.image_id,
                "category_id": category_id,
                "segmentation": [],
                "area": abs_w * abs_h,
                "bbox": [abs_x, abs_y, abs_w, abs_h],
                "iscrowd": 0
            })
            
            self.annotation_id += 1
        self.image_id += 1
        print(f"   ✅ Engineered: {filename} ({len(items)} objects)")

    def save(self):
        """Saves the current COCO dataset to disk."""
        output_path = os.path.join(self.output_folder, "coco.json")
        with open(output_path, 'w') as f:
            json.dump(self.coco_data, f, indent=4)
        print(f"⚙️  Engineer: Saved COCO dataset to {output_path}")
        return output_path

    def engineer(self, annotations, query):
        """Legacy method for batch processing."""
        print(f"⚙️  Engineer: Formatting dataset for '{query}'...")
        # Re-init for batch
        self.__init__(self.output_folder, query)
        
        for filename, data in annotations.items():
            self.process_item(filename, data)
            
        return self.save()
